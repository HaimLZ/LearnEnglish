<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>üåü Word Wizard ‚Äì Spelling Adventure</title>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Baloo+2:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --sky: #0f172a;
    --card: #1e293b;
    --card2: #263548;
    --accent: #f59e0b;
    --accent2: #10b981;
    --danger: #ef4444;
    --text: #f1f5f9;
    --muted: #94a3b8;
    --star: #fbbf24;
    --radius: 18px;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Nunito', sans-serif;
    background: var(--sky);
    color: var(--text);
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    overflow-x: hidden;
    background-image:
      radial-gradient(ellipse at 20% 10%, rgba(245,158,11,0.07) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 90%, rgba(16,185,129,0.07) 0%, transparent 50%);
  }

  /* Version badge */
  .version-badge {
    position: fixed;
    top: 8px;
    left: 10px;
    z-index: 3;
    font-size: 0.68rem;
    color: rgba(241,245,249,0.75);
    letter-spacing: 0.4px;
    user-select: none;
    pointer-events: none;
  }

  /* Stars */
  .stars { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .star-dot {
    position: absolute;
    background: white;
    border-radius: 50%;
    animation: twinkle var(--d, 3s) ease-in-out infinite alternate;
  }
  @keyframes twinkle { from { opacity: 0.1; } to { opacity: 0.7; } }

  .container {
    position: relative; z-index: 1;
    width: 100%; max-width: 980px;
    padding: 16px;
    display: flex; flex-direction: column; align-items: center;
    gap: 20px;
    padding-bottom: 40px;
  }

  /* Header */
  header {
    text-align: center;
    padding-top: 12px;
  }
  header h1 {
    font-family: 'Baloo 2', cursive;
    font-size: clamp(2rem, 7vw, 3rem);
    font-weight: 800;
    background: linear-gradient(135deg, #f59e0b, #fbbf24, #34d399);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    filter: drop-shadow(0 2px 8px rgba(245,158,11,0.4));
    line-height: 1.1;
  }
  header p {
    color: var(--muted);
    font-size: 0.95rem;
    margin-top: 4px;
  }

  /* Score strip */
  .score-strip {
    display: flex; gap: 16px; justify-content: center;
    width: 100%;
  }
  .score-pill {
    flex: 1;
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.07);
    border-radius: 999px;
    padding: 10px 20px;
    text-align: center;
    font-weight: 700;
  }
  .score-pill .label { font-size: 0.7rem; color: var(--muted); text-transform: uppercase; letter-spacing: 1px; }
  .score-pill .value { font-size: 1.4rem; color: var(--accent); font-family: 'Baloo 2', cursive; }

  /* Word card */
  .word-card {
    width: 100%;
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: var(--radius);
    padding: 24px 20px;
    text-align: center;
    display: flex; flex-direction: column; align-items: center;
    gap: 16px;
    box-shadow: 0 8px 40px rgba(0,0,0,0.4);
  }
  .game-layout {
    width: 100%;
    display: grid;
    grid-template-columns: minmax(0, 1.9fr) minmax(240px, 1fr);
    gap: 14px;
    align-items: start;
  }

  /* Misspelling history */
  .misspell-card {
    width: 100%;
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: var(--radius);
    padding: 14px 14px 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.35);
  }
  .misspell-title {
    font-family: 'Baloo 2', cursive;
    font-size: 1.1rem;
    color: #fcd34d;
    margin-bottom: 8px;
  }
  .misspell-note {
    color: var(--muted);
    font-size: 0.8rem;
    margin-bottom: 10px;
  }
  .misspell-list {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 420px;
    overflow-y: auto;
    padding-right: 2px;
  }
  .misspell-item {
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    padding: 8px 10px;
    background: rgba(255,255,255,0.03);
  }
  .misspell-word {
    color: #fde68a;
    font-weight: 800;
    font-size: 0.85rem;
    margin-bottom: 4px;
  }
  .misspell-attempts {
    color: #fca5a5;
    font-size: 0.82rem;
    line-height: 1.35;
    word-break: break-word;
  }
  .misspell-empty {
    color: var(--muted);
    font-size: 0.83rem;
    border: 1px dashed rgba(255,255,255,0.16);
    border-radius: 10px;
    padding: 10px;
    text-align: center;
  }

  /* Speak button */
  .speak-btn {
    background: linear-gradient(135deg, #f59e0b, #fbbf24);
    border: none; cursor: pointer;
    border-radius: 999px;
    padding: 14px 32px;
    font-family: 'Baloo 2', cursive;
    font-size: 1.089rem;
    font-weight: 700;
    color: #1a1a1a;
    display: flex; align-items: center; gap: 10px;
    box-shadow: 0 4px 20px rgba(245,158,11,0.4);
    transition: transform 0.15s, box-shadow 0.15s;
    -webkit-tap-highlight-color: transparent;
  }
  .speak-btn:hover { transform: scale(1.05); box-shadow: 0 6px 30px rgba(245,158,11,0.5); }
  .speak-btn:active { transform: scale(0.97); }
  .speak-btn .speaker-icon { font-size: 1.5rem; animation: none; }
  .speak-btn.speaking .speaker-icon { animation: pulse 0.5s ease-in-out infinite alternate; }
  @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.3); } }
  .action-row {
    width: 100%;
    display: grid;
    grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
    gap: 10px;
  }
  .action-row .speak-btn {
    width: 100%;
    min-width: 0;
    justify-content: center;
  }
  .action-row .speak-btn span:last-child {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Hint area */
  .hint-area {
    min-height: 36px;
    display: flex; align-items: center; gap: 6px; flex-wrap: wrap; justify-content: center;
  }
  .letter-box {
    width: 36px; height: 36px;
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.05);
    display: flex; align-items: center; justify-content: center;
    font-family: 'Baloo 2', cursive;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--accent);
    transition: all 0.3s;
  }
  .letter-box.revealed {
    background: rgba(245,158,11,0.15);
    border-color: var(--accent);
    animation: pop 0.3s ease;
  }
  @keyframes pop { 0% { transform: scale(0.5); } 80% { transform: scale(1.1); } 100% { transform: scale(1); } }

  /* Failure dots */
  .failure-dots {
    display: flex; gap: 6px;
    align-items: center;
  }
  .fdot {
    width: 12px; height: 12px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    border: 2px solid rgba(255,255,255,0.2);
    transition: all 0.3s;
  }
  .fdot.lit { background: var(--danger); border-color: var(--danger); box-shadow: 0 0 8px var(--danger); }

  /* Input area */
  .input-row {
    width: 100%;
    display: flex; gap: 10px;
  }
  #wordInput {
    flex: 1;
    background: var(--card2);
    border: 2px solid rgba(255,255,255,0.1);
    border-radius: 12px;
    padding: 14px 18px;
    font-family: 'Nunito', sans-serif;
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--text);
    outline: none;
    transition: border-color 0.2s;
    caret-color: var(--accent);
    text-transform: lowercase;
  }
  #wordInput:focus { border-color: var(--accent); }
  #wordInput.shake { animation: shake 0.4s ease; }
  #wordInput.correct-flash { border-color: var(--accent2); background: rgba(16,185,129,0.1); }
  @keyframes shake {
    0%,100% { transform: translateX(0); }
    20% { transform: translateX(-8px); }
    40% { transform: translateX(8px); }
    60% { transform: translateX(-6px); }
    80% { transform: translateX(6px); }
  }

  .submit-btn {
    background: linear-gradient(135deg, #10b981, #34d399);
    border: none; cursor: pointer;
    border-radius: 12px;
    padding: 14px 22px;
    font-size: 1.5rem;
    box-shadow: 0 4px 20px rgba(16,185,129,0.3);
    transition: transform 0.15s, box-shadow 0.15s;
    -webkit-tap-highlight-color: transparent;
  }
  .submit-btn:hover { transform: scale(1.07); }
  .submit-btn:active { transform: scale(0.96); }

  /* Feedback bar */
  .feedback {
    font-size: 1rem;
    font-weight: 700;
    padding: 10px 20px;
    border-radius: 999px;
    background: rgba(255,255,255,0.05);
    color: var(--muted);
    text-align: center;
    min-height: 44px;
    display: flex; align-items: center; justify-content: center;
    width: 100%;
    transition: all 0.3s;
  }
  .feedback.good { background: rgba(16,185,129,0.15); color: #34d399; }
  .feedback.bad  { background: rgba(239,68,68,0.15);  color: #f87171; }
  .feedback.info { background: rgba(245,158,11,0.1);  color: #fbbf24; }

  /* Step tracker */
  .steps-track {
    width: 100%;
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 8px;
  }
  .step-pill {
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.04);
    border-radius: 10px;
    padding: 8px 10px;
    text-align: center;
    font-size: 0.78rem;
    font-weight: 700;
    color: var(--muted);
    transition: all 0.2s;
  }
  .step-pill.active {
    border-color: rgba(245,158,11,0.75);
    color: #fde68a;
    background: rgba(245,158,11,0.18);
  }
  .step-pill.done {
    border-color: rgba(16,185,129,0.7);
    color: #6ee7b7;
    background: rgba(16,185,129,0.18);
  }

  /* Stage options (V1/V2 + Hebrew meaning) */
  .stage-section {
    width: 100%;
    display: none;
    flex-direction: column;
    gap: 10px;
    margin-top: 6px;
  }
  .stage-section.active { display: flex; }
  .stage-label {
    color: var(--muted);
    font-size: 0.88rem;
    font-weight: 700;
    text-align: left;
  }
  .options-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 10px;
  }
  .options-grid.hebrew {
    grid-template-columns: 1fr;
  }
  .option-btn {
    background: var(--card2);
    border: 1px solid rgba(255,255,255,0.14);
    border-radius: 12px;
    color: var(--text);
    padding: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.12s, background 0.2s, border-color 0.2s;
  }
  .option-btn:hover { transform: translateY(-1px); border-color: rgba(245,158,11,0.55); }
  .option-btn.correct { background: rgba(16,185,129,0.2); border-color: #10b981; color: #6ee7b7; }
  .option-btn.wrong { background: rgba(239,68,68,0.2); border-color: #ef4444; color: #fca5a5; }
  .option-btn:disabled { cursor: default; opacity: 0.9; }

  .next-inline-btn {
    display: none;
    width: 100%;
    background: linear-gradient(135deg, #f59e0b, #fbbf24);
    color: #1a1a1a;
    border: none;
    border-radius: 12px;
    padding: 12px 16px;
    font-family: 'Baloo 2', cursive;
    font-size: 1.15rem;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.12s;
  }
  .next-inline-btn:hover { transform: scale(1.02); }

  /* Word complete modal overlay */
  .overlay {
    display: none;
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center; justify-content: center;
  }
  .overlay.active { display: flex; }
  .modal {
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 24px;
    padding: 36px 32px;
    text-align: center;
    max-width: 340px;
    width: 90%;
    animation: modalIn 0.4s cubic-bezier(0.34,1.56,0.64,1);
    box-shadow: 0 20px 80px rgba(0,0,0,0.6);
  }
  @keyframes modalIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
  .modal .emoji { font-size: 4rem; line-height: 1.2; }
  .modal h2 { font-family: 'Baloo 2', cursive; font-size: 2rem; margin: 8px 0 4px; }
  .modal .the-word {
    font-family: 'Baloo 2', cursive;
    font-size: 2.5rem;
    color: var(--accent);
    margin-bottom: 16px;
    letter-spacing: 4px;
  }
  .modal p { color: var(--muted); margin-bottom: 24px; font-size: 0.95rem; }
  .modal-actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .next-btn {
    background: linear-gradient(135deg, #f59e0b, #fbbf24);
    border: none; cursor: pointer;
    border-radius: 999px;
    padding: 14px 36px;
    font-family: 'Baloo 2', cursive;
    font-size: 1.2rem;
    font-weight: 700;
    color: #1a1a1a;
    box-shadow: 0 4px 20px rgba(245,158,11,0.4);
    transition: transform 0.15s;
    width: 100%;
  }
  .next-btn:hover { transform: scale(1.04); }
  .share-btn {
    background: linear-gradient(135deg, #10b981, #34d399);
    color: #052e16;
    box-shadow: 0 4px 20px rgba(16,185,129,0.35);
  }

  /* Confetti */
  .confetti-piece {
    position: fixed;
    width: 10px; height: 10px;
    border-radius: 2px;
    pointer-events: none;
    z-index: 200;
    animation: confettiFall var(--dur,2s) ease-in forwards;
  }
  @keyframes confettiFall {
    0%   { transform: translateY(-20px) rotate(0deg); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
  }

  /* Word pool editor */
  .words-section {
    width: 100%;
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.07);
    border-radius: var(--radius);
    padding: 20px;
  }
  .words-section summary {
    cursor: pointer;
    font-weight: 700;
    font-size: 1rem;
    color: var(--muted);
    list-style: none;
    display: flex; align-items: center; gap: 8px;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  .words-section summary::-webkit-details-marker { display: none; }
  .words-section[open] summary { color: var(--accent); }
  .words-section .inner { margin-top: 14px; display: flex; flex-direction: column; gap: 10px; }
  #poolTextarea {
    width: 100%;
    background: var(--card2);
    border: 2px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    padding: 12px 14px;
    font-family: 'Nunito', sans-serif;
    font-size: 0.9rem;
    color: var(--text);
    outline: none;
    resize: vertical;
    min-height: 100px;
    line-height: 1.6;
  }
  #poolTextarea:focus { border-color: var(--accent); }
  .save-pool-btn {
    background: var(--card2);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 999px;
    padding: 10px 24px;
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    cursor: pointer;
    align-self: flex-start;
    transition: background 0.2s;
  }
  .save-pool-btn:hover { background: rgba(245,158,11,0.15); }

  .word-count-badge {
    background: rgba(245,158,11,0.15);
    color: var(--accent);
    border-radius: 999px;
    padding: 2px 10px;
    font-size: 0.8rem;
    font-weight: 700;
  }

  @media (max-width: 400px) {
    .letter-box { width: 30px; height: 30px; font-size: 1rem; }
    .container { padding-left: 10px; padding-right: 10px; }
    .word-card { padding: 20px 12px; }
    .score-strip { gap: 10px; }
    .speak-btn { padding: 12px 14px; font-size: 0.9rem; }
    .action-row { gap: 8px; }
  }
  @media (max-width: 900px) {
    .game-layout { grid-template-columns: 1fr; }
    .misspell-list { max-height: 220px; }
  }
</style>
</head>
<body>

<!-- Version label is bound to the VERSION constant at boot to keep a single source of truth. -->
<div class="version-badge" id="versionBadge"></div>
<div class="stars" id="stars"></div>

<!-- Challenge complete overlay is used instead of alert(), so we can provide share + restart actions. -->
<div class="overlay" id="challengeOverlay">
  <div class="modal">
    <div class="emoji">üèÅ</div>
    <h2>Challenge Complete!</h2>
    <p>Your Final Score: <strong id="challengeFinalScore">0</strong></p>
    <p>Your Final Streak: <strong id="challengeFinalStreak">0</strong></p>
    <div class="modal-actions">
      <button class="next-btn share-btn" onclick="shareFinalScore()">Share Score</button>
      <button class="next-btn" onclick="dismissChallengeCompleteAndRestart()">Start Over</button>
    </div>
  </div>
</div>

<div class="container">
  <header>
    <h1>‚ú® Word Wizard</h1>
    <p>Spelling Adventure</p>
  </header>

  <!-- Score -->
  <div class="score-strip">
    <div class="score-pill"><div class="label">Score</div><div class="value" id="scoreVal">0</div></div>
    <div class="score-pill"><div class="label">Streak</div><div class="value" id="streakVal">üî• 0</div></div>
    <div class="score-pill"><div class="label">Words</div><div class="value" id="wordsVal">0</div></div>
  </div>

  <!-- Main game area -->
  <div class="game-layout">
    <div class="word-card">
      <div class="action-row">
        <button class="speak-btn" id="speakBtn" onclick="speakWord()">
          <span class="speaker-icon">üîä</span>
          <span>Hear</span>
        </button>
        <button class="speak-btn" onclick="startOverGame()">
          <span>üîÑ</span>
          <span>Start Over</span>
        </button>
      </div>

      <!-- Failure dots -->
      <div class="failure-dots" id="failureDots"></div>

      <!-- Letter hint boxes -->
      <div class="hint-area" id="hintArea"></div>

      <div class="steps-track" id="stepsTrack">
        <div class="step-pill active" id="stepSpell">1) Spell</div>
        <div class="step-pill" id="stepTense">2) V1 / V2</div>
        <div class="step-pill" id="stepHebrew">3) Hebrew</div>
      </div>

      <!-- Input -->
      <div class="input-row">
        <input type="text" id="wordInput" placeholder="Type the word‚Ä¶" autocomplete="off"
               autocorrect="off" autocapitalize="none" spellcheck="false"
               onkeydown="handleKey(event)" />
        <button class="submit-btn" onclick="checkWord()" title="Submit">‚úì</button>
      </div>

      <div class="feedback" id="feedback">Press üîä to hear the word, then spell it!</div>

      <div class="stage-section" id="tenseSection">
        <div class="stage-label">Choose the correct form:</div>
        <div class="options-grid" id="tenseOptions"></div>
      </div>

      <div class="stage-section" id="hebrewSection">
        <div class="stage-label">Choose the matching Hebrew meaning:</div>
        <div class="options-grid hebrew" id="hebrewOptions"></div>
      </div>

      <button class="next-inline-btn" id="nextInlineBtn" onclick="nextWord()">Next Word ‚Üí</button>
    </div>

    <aside class="misspell-card">
      <div class="misspell-title">‚úçÔ∏è Misspell History</div>
      <div class="misspell-note">For each target word, shows all wrong spellings typed so far.</div>
      <ul class="misspell-list" id="misspellList"></ul>
    </aside>
  </div>

  <!-- Word pool editor -->
  <details class="words-section" id="wordPoolDetails">
    <summary>
      üìö Word Pool
      <span class="word-count-badge" id="wordCountBadge">0 words</span>
    </summary>
    <div class="inner">
      <p style="color:var(--muted);font-size:0.85rem;">One row per line in this format: V1 | V2 | Hebrew</p>
      <textarea id="poolTextarea"></textarea>
      <button class="save-pool-btn" onclick="savePool()">üíæ Save Pool</button>
    </div>
  </details>
</div>

<script>
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//  WORD POOL (V1, V2, Hebrew)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DEFAULT_WORDS = [
  { v1: "Sit",     v2: "Sat",     hebrew: "◊ú◊©◊ë◊™" },
  { v1: "Drink",   v2: "Drank",   hebrew: "◊ú◊©◊™◊ï◊™" },
  { v1: "Sing",    v2: "Sang",    hebrew: "◊ú◊©◊ô◊®" },
  { v1: "Swim",    v2: "Swam",    hebrew: "◊ú◊©◊ó◊ï◊™" },
  { v1: "Begin",   v2: "Began",   hebrew: "◊ú◊î◊™◊ó◊ô◊ú" },
  { v1: "Give",    v2: "Gave",    hebrew: "◊ú◊™◊™" },
  { v1: "Get",     v2: "Got",     hebrew: "◊ú◊ß◊ë◊ú" },
  { v1: "Forget",  v2: "Forgot",  hebrew: "◊ú◊©◊õ◊ï◊ó" },
  { v1: "Shoot",   v2: "Shot",    hebrew: "◊ú◊ô◊®◊ï◊™" },
  { v1: "Fly",     v2: "Flew",    hebrew: "◊ú◊ò◊ï◊°/◊ú◊¢◊ï◊£" },
  { v1: "Draw",    v2: "Drew",    hebrew: "◊ú◊¶◊ô◊ô◊®" },
  { v1: "Throw",   v2: "Threw",   hebrew: "◊ú◊ñ◊®◊ï◊ß" },
  { v1: "Grow",    v2: "Grew",    hebrew: "◊ú◊í◊ì◊ï◊ú/◊ú◊í◊ì◊ú" },
  { v1: "Know",    v2: "Knew",    hebrew: "◊ú◊ì◊¢◊™/◊ú◊î◊õ◊ô◊®" },
  { v1: "Blow",    v2: "Blew",    hebrew: "◊ú◊†◊©◊ï◊ë/◊ú◊†◊©◊ï◊£" },
  { v1: "Break",   v2: "Broke",   hebrew: "◊ú◊©◊ë◊ï◊®" },
  { v1: "Speak",   v2: "Spoke",   hebrew: "◊ú◊ì◊ë◊®" },
  { v1: "Write",   v2: "Wrote",   hebrew: "◊ú◊õ◊™◊ï◊ë" },
  { v1: "Drive",   v2: "Drove",   hebrew: "◊ú◊†◊î◊ï◊í/◊ú◊†◊°◊ï◊¢" },
  { v1: "Ride",    v2: "Rode",    hebrew: "◊ú◊®◊õ◊ë" },
  { v1: "Steal",   v2: "Stole",   hebrew: "◊ú◊í◊†◊ï◊ë" },
  { v1: "Wake",    v2: "Woke",    hebrew: "◊ú◊î◊™◊¢◊ï◊®◊®" },
  { v1: "Wear",    v2: "Wore",    hebrew: "◊ú◊ú◊ë◊ï◊©" },
  { v1: "Lose",    v2: "Lost",    hebrew: "◊ú◊î◊§◊°◊ô◊ì" },
  { v1: "Win",     v2: "Won",     hebrew: "◊ú◊†◊¶◊ó" },
  { v1: "Run",     v2: "Ran",     hebrew: "◊ú◊®◊ï◊•" },
  { v1: "Buy",     v2: "Bought",  hebrew: "◊ú◊ß◊†◊ï◊™" },
  { v1: "Bring",   v2: "Brought", hebrew: "◊ú◊î◊ë◊ô◊ê" },
  { v1: "Fight",   v2: "Fought",  hebrew: "◊ú◊®◊ô◊ë/◊ú◊î◊ô◊ú◊ó◊ù" },
  { v1: "Think",   v2: "Thought", hebrew: "◊ú◊ó◊©◊ï◊ë" },
  { v1: "Go",      v2: "Went",    hebrew: "◊ú◊ú◊õ◊™" },
  { v1: "Have",    v2: "Had",     hebrew: "◊§◊ï◊¢◊ú ◊©◊ô◊ô◊õ◊ï◊™" },
  { v1: "Take",    v2: "Took",    hebrew: "◊ú◊ß◊ó◊™" },
  { v1: "See",     v2: "Saw",     hebrew: "◊ú◊®◊ê◊ï◊™" },
  { v1: "Hear",    v2: "Heard",   hebrew: "◊ú◊©◊û◊ï◊¢" },
  { v1: "Make",    v2: "Made",    hebrew: "◊ú◊î◊õ◊ô◊ü" },
  { v1: "Do",      v2: "Did",     hebrew: "◊ú◊¢◊©◊ï◊™" },
  { v1: "Find",    v2: "Found",   hebrew: "◊ú◊û◊¶◊ï◊ê" },
  { v1: "Eat",     v2: "Ate",     hebrew: "◊ú◊ê◊õ◊ï◊ú" },
  { v1: "Lie",     v2: "Lay",     hebrew: "◊ú◊©◊ß◊®/◊ú◊©◊õ◊ë" }
];

const STORAGE_KEY = "wordwizard_pool_v2";
const SCORE_KEY   = "wordwizard_score";
const LEGACY_STORAGE_KEY = "wordwizard_pool";
// VERSION follows Major.Minor.Build.Revision and Revision increments on each code change.
const VERSION = "1.2.0.1";

// ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let wordPool = [];
let currentEntry = null;
let currentPromptForm = "v1";
let currentPromptWord = "";
let currentPromptKey = "";
let failures = 0;
let score = parseInt(localStorage.getItem(SCORE_KEY) || "0", 10);
let streak = 0;
let wordPlayed = false; // The user must hear the spoken word before typing.
let stage = "spelling"; // spelling -> tense -> hebrew -> complete
let englishVoices = [];
let lastVoiceURI = "";
const misspellAttemptsByWord = {};
let remainingPrompts = [];
const attemptedPromptKeys = new Set();
let finalChallengeScore = 0;
let finalChallengeStreak = 0;
let speechStyleIndex = -1;
const SPEECH_STYLES = [
  { rate: 0.75, pitch: 0.95 },
  { rate: 0.84, pitch: 1.05 },
  { rate: 0.7, pitch: 1.15 },
  { rate: 0.8, pitch: 0.9 }
];

// ‚îÄ‚îÄ Audio (Web Audio API) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function getCtx() {
  if (!audioCtx) audioCtx = new AudioCtx();
  return audioCtx;
}

function playTone(type) {
  const ctx = getCtx();
  if (type === "win") {
    // A quick ascending chord makes successful answers feel rewarding.
    const notes = [523, 659, 784, 1047];
    notes.forEach((freq, i) => {
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type = "sine";
      o.frequency.value = freq;
      const t = ctx.currentTime + i * 0.12;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.25, t + 0.04);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
      o.start(t); o.stop(t + 0.5);
    });
  } else {
    // A short buzz signals wrong answers without blocking retry.
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    o.type = "sawtooth";
    o.frequency.value = 120;
    g.gain.setValueAtTime(0.3, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.35);
    o.start(); o.stop(ctx.currentTime + 0.35);
  }
}

// ‚îÄ‚îÄ TTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function refreshEnglishVoices() {
  // Mobile browsers sometimes expose only one English voice.
  // If that happens, fallback to the full voice list so rotation can still happen.
  const allVoices = speechSynthesis.getVoices();
  const englishOnly = allVoices.filter((voice) => (voice.lang || "").toLowerCase().startsWith("en"));
  englishVoices = englishOnly.length > 0 ? englishOnly : allVoices;
}

function getRotatingVoice() {
  if (englishVoices.length === 0) refreshEnglishVoices();
  if (englishVoices.length === 0) return null;
  if (englishVoices.length === 1) return englishVoices[0];

  // Keep pressing "Hear the Word" fresh by avoiding the same voice twice in a row.
  const candidates = englishVoices.filter((voice) => voice.voiceURI !== lastVoiceURI);
  const voice = candidates[Math.floor(Math.random() * candidates.length)];
  return voice || englishVoices[0];
}

function initVoices() {
  // Browser voices may load asynchronously, so we refresh now and whenever they change.
  refreshEnglishVoices();
  speechSynthesis.onvoiceschanged = () => refreshEnglishVoices();
}

function getNextSpeechStyle(hasMultipleVoices) {
  if (hasMultipleVoices) {
    // Keep a neutral style when we already rotate by voice identity.
    return { rate: 0.77, pitch: 1.05 };
  }

  // With a single voice, rotate rate/pitch presets so each press sounds different.
  speechStyleIndex = (speechStyleIndex + 1) % SPEECH_STYLES.length;
  return SPEECH_STYLES[speechStyleIndex];
}

function speakWord() {
  if (!currentPromptWord) return;
  wordPlayed = true;
  const btn = document.getElementById("speakBtn");
  btn.classList.add("speaking");

  // The spoken prompt always matches the randomly chosen visible target (V1 or V2).
  refreshEnglishVoices();
  const utt = new SpeechSynthesisUtterance(currentPromptWord);
  const selectedVoice = getRotatingVoice();
  const style = getNextSpeechStyle(englishVoices.length > 1);
  if (selectedVoice) {
    utt.voice = selectedVoice;
    utt.lang = selectedVoice.lang || "en-US";
    lastVoiceURI = selectedVoice.voiceURI;
  } else {
    utt.lang = "en-US";
  }
  utt.rate = style.rate;
  utt.pitch = style.pitch;
  utt.onend = () => btn.classList.remove("speaking");
  utt.onerror = () => btn.classList.remove("speaking");
  speechSynthesis.cancel();
  speechSynthesis.speak(utt);

  if (stage === "spelling") setFeedback("Type the word you heard!", "info");
  document.getElementById("wordInput").focus();
}

// ‚îÄ‚îÄ Game logic ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getTotalPromptCount() {
  // Each pool row contributes two unique challenge prompts: V1 and V2.
  return wordPool.length * 2;
}

function buildPromptDeck() {
  remainingPrompts = [];
  attemptedPromptKeys.clear();

  // Build a non-repeating challenge deck where V1 and V2 are separate prompts.
  wordPool.forEach((entry, index) => {
    const v1Word = String(entry.v1 || "").trim().toLowerCase();
    const v2Word = String(entry.v2 || "").trim().toLowerCase();
    if (v1Word) {
      remainingPrompts.push({ key: `${index}-v1`, entry, form: "v1", promptWord: v1Word });
    }
    if (v2Word) {
      remainingPrompts.push({ key: `${index}-v2`, entry, form: "v2", promptWord: v2Word });
    }
  });
}

function pickPrompt() {
  if (remainingPrompts.length === 0) return null;
  const idx = Math.floor(Math.random() * remainingPrompts.length);
  const prompt = remainingPrompts.splice(idx, 1)[0];
  attemptedPromptKeys.add(prompt.key);
  return prompt;
}

function isChallengeComplete() {
  return attemptedPromptKeys.size >= getTotalPromptCount();
}

function showChallengeCompleteThenRestart() {
  // Store final score before reset so both UI and share action use the same value.
  finalChallengeScore = score;
  finalChallengeStreak = streak;
  const finalMessage = `Challenge Complete! Your Final Score: ${finalChallengeScore}`;
  setFeedback(finalMessage, "good");

  const overlay = document.getElementById("challengeOverlay");
  const finalScoreEl = document.getElementById("challengeFinalScore");
  const finalStreakEl = document.getElementById("challengeFinalStreak");
  if (finalScoreEl) finalScoreEl.textContent = String(finalChallengeScore);
  if (finalStreakEl) finalStreakEl.textContent = String(finalChallengeStreak);
  if (overlay) overlay.classList.add("active");
}

function buildShareScoreImageFile() {
  // Build a square score card image for chat apps that preview shared images.
  const canvas = document.createElement("canvas");
  canvas.width = 1080;
  canvas.height = 1080;
  const ctx = canvas.getContext("2d");
  if (!ctx) return Promise.resolve(null);

  // Reuse the app palette so shared media feels consistent with the game.
  const bg = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  bg.addColorStop(0, "#0f172a");
  bg.addColorStop(1, "#1e293b");
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = "rgba(245,158,11,0.55)";
  ctx.lineWidth = 10;
  ctx.strokeRect(36, 36, canvas.width - 72, canvas.height - 72);

  ctx.textAlign = "center";
  ctx.fillStyle = "#f8fafc";
  ctx.font = "700 70px Nunito, Arial, sans-serif";
  ctx.fillText("Word Wizard", canvas.width / 2, 170);

  ctx.fillStyle = "#fbbf24";
  ctx.font = "900 96px Nunito, Arial, sans-serif";
  ctx.fillText("Challenge Complete", canvas.width / 2, 300);

  ctx.fillStyle = "#cbd5e1";
  ctx.font = "700 50px Nunito, Arial, sans-serif";
  ctx.fillText("Total Score", canvas.width / 2, 445);

  ctx.fillStyle = "#34d399";
  ctx.font = "900 170px Nunito, Arial, sans-serif";
  ctx.fillText(String(finalChallengeScore), canvas.width / 2, 605);

  ctx.fillStyle = "#cbd5e1";
  ctx.font = "700 50px Nunito, Arial, sans-serif";
  ctx.fillText("Final Streak", canvas.width / 2, 730);

  ctx.fillStyle = "#f59e0b";
  ctx.font = "900 130px Nunito, Arial, sans-serif";
  ctx.fillText(String(finalChallengeStreak), canvas.width / 2, 870);

  ctx.fillStyle = "rgba(148,163,184,0.9)";
  ctx.font = "600 34px Nunito, Arial, sans-serif";
  ctx.fillText(`Version ${VERSION}`, canvas.width / 2, 980);

  return new Promise((resolve) => {
    canvas.toBlob((blob) => {
      if (!blob) {
        resolve(null);
        return;
      }
      resolve(new File([blob], "word-wizard-score.png", { type: "image/png" }));
    }, "image/png");
  });
}

async function shareFinalScore() {
  const shareText = `My Word Wizard Score Is ${finalChallengeScore}! Can you beat me? https://haimlz.github.io/LearnEnglish/`;
  const shareImage = await buildShareScoreImageFile();

  // Try rich share first so devices can attach the score image automatically.
  if (navigator.share) {
    try {
      if (shareImage && navigator.canShare && navigator.canShare({ files: [shareImage] })) {
        await navigator.share({
          text: shareText,
          files: [shareImage]
        });
        return;
      }

      // If file sharing is unsupported, fallback to plain text share.
      await navigator.share({ text: shareText });
      return;
    } catch (error) {
      // If the user cancels sharing, keep silent; otherwise continue to fallback copy.
      if (error && error.name === "AbortError") return;
    }
  }

  // Clipboard fallback keeps sharing useful on browsers without navigator.share support.
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(shareText);
      setFeedback("üìã Score text copied! Paste it anywhere to share.", "info");
      return;
    } catch {
      // Continue to the final fallback if clipboard write fails.
    }
  }

  // Final fallback guarantees the user can still copy the exact text manually.
  prompt("Copy and share your score:", shareText);
}

function dismissChallengeCompleteAndRestart() {
  const overlay = document.getElementById("challengeOverlay");
  if (overlay) overlay.classList.remove("active");
  // Once dismissed, we run the same full reset flow as Start Over.
  startOverGame();
}

function resetStageUI() {
  // Keep all stage containers hidden until the relevant step is reached.
  document.getElementById("tenseSection").classList.remove("active");
  document.getElementById("hebrewSection").classList.remove("active");
  document.getElementById("tenseOptions").innerHTML = "";
  document.getElementById("hebrewOptions").innerHTML = "";
  document.getElementById("nextInlineBtn").style.display = "none";
}

function updateStepIndicator() {
  const stepSpell = document.getElementById("stepSpell");
  const stepTense = document.getElementById("stepTense");
  const stepHebrew = document.getElementById("stepHebrew");
  const orderedSteps = [
    { key: "spelling", el: stepSpell },
    { key: "tense", el: stepTense },
    { key: "hebrew", el: stepHebrew }
  ];

  // The tracker marks previous steps as done and highlights the current step.
  const currentIndex = stage === "complete"
    ? orderedSteps.length
    : orderedSteps.findIndex((item) => item.key === stage);

  orderedSteps.forEach((item, index) => {
    item.el.classList.remove("active", "done");
    if (currentIndex > index) item.el.classList.add("done");
    if (currentIndex === index) item.el.classList.add("active");
  });
}

function startNewWord() {
  const nextPrompt = pickPrompt();
  if (!nextPrompt) {
    // Safety guard: if the deck is unexpectedly empty, complete and restart cleanly.
    showChallengeCompleteThenRestart();
    return;
  }

  currentEntry = nextPrompt.entry;
  currentPromptForm = nextPrompt.form;
  currentPromptWord = nextPrompt.promptWord;
  currentPromptKey = nextPrompt.key;

  failures = 0;
  wordPlayed = false;
  stage = "spelling";
  updateStepIndicator();
  updateScoreDisplay();

  resetStageUI();
  renderFailureDots();
  renderHints();

  const input = document.getElementById("wordInput");
  input.value = "";
  input.className = "";
  input.disabled = false;

  setFeedback("Press üîä to hear the word, then spell it!", "");
  setTimeout(speakWord, 500);
}

function nextWord() {
  // The side misspell history is intended to describe only the current round,
  // so we wipe all recorded attempts before loading the next target word.
  Object.keys(misspellAttemptsByWord).forEach((wordKey) => {
    delete misspellAttemptsByWord[wordKey];
  });
  renderMisspellList();

  if (remainingPrompts.length === 0) {
    showChallengeCompleteThenRestart();
    return;
  }
  startNewWord();
}

function startOverGame(showResetMessage = true) {
  // Reset every accumulated game-progress metric to create a fully fresh session.
  score = 0;
  streak = 0;
  failures = 0;
  wordPlayed = false;
  stage = "spelling";
  speechStyleIndex = -1;
  currentPromptKey = "";
  finalChallengeScore = 0;
  finalChallengeStreak = 0;
  localStorage.removeItem(SCORE_KEY);

  // Clear all tracked misspellings so historical side data also starts clean.
  Object.keys(misspellAttemptsByWord).forEach((wordKey) => {
    delete misspellAttemptsByWord[wordKey];
  });
  renderMisspellList();

  // Rebuild the non-repeating prompt deck so the challenge starts from prompt 1 again.
  buildPromptDeck();
  updateScoreDisplay();

  // Ensure any queued or ongoing speech is cancelled before starting the new round.
  speechSynthesis.cancel();
  startNewWord();
  // Boot-time reset should be silent, while manual Start Over still shows user feedback.
  if (showResetMessage) {
    setFeedback("üîÑ Fresh start! Score, streak, words, and attempts were reset.", "info");
  }
}

function handleKey(e) {
  if (e.key !== "Enter") return;

  // Enter remains active only during spelling to avoid accidental submissions in later steps.
  if (stage === "spelling") checkWord();
}

function checkWord() {
  if (stage !== "spelling") return;

  const input = document.getElementById("wordInput");
  const typed = input.value.trim().toLowerCase();

  if (!wordPlayed) {
    setFeedback("üîä Hear the word first!", "bad");
    return;
  }
  if (!typed) {
    setFeedback("‚úèÔ∏è Type something!", "info");
    return;
  }

  if (typed === currentPromptWord) {
    // Stage 1 complete: unlock the V1/V2 recognition step.
    playTone("win");
    input.classList.add("correct-flash");
    stage = "tense";
    updateStepIndicator();
    renderTenseOptions();
    setFeedback("‚úÖ Correct spelling! Now choose the right form (V1 or V2).", "good");
  } else {
    failures++;
    // Persist each wrong typed spelling under the active target word for side history review.
    recordMisspellAttempt(currentPromptWord, typed);
    playTone("error");
    input.value = "";
    input.classList.add("shake");
    setTimeout(() => input.classList.remove("shake"), 500);

    const msgs = [
      "Not quite ‚Äî try again! üí™",
      "Hmm, not right‚Ä¶ you can do it! üßê",
      "Keep trying! Listen again üîä",
      "Almost! Don't give up! ‚ú®",
      "You're so close! üåü"
    ];
    setFeedback(msgs[Math.min(failures - 1, msgs.length - 1)], "bad");

    renderFailureDots();
    renderHints();

    if (failures === 3 || failures === 6) setTimeout(speakWord, 400);
  }
}

function recordMisspellAttempt(targetWord, attemptedWord) {
  const wordKey = String(targetWord || "").trim().toLowerCase();
  const attemptValue = String(attemptedWord || "").trim().toLowerCase();
  if (!wordKey || !attemptValue) return;

  // Keep insertion order by creating an array once and appending every attempt (including repeats).
  if (!Array.isArray(misspellAttemptsByWord[wordKey])) misspellAttemptsByWord[wordKey] = [];
  misspellAttemptsByWord[wordKey].push(attemptValue);
  renderMisspellList();
}

function renderMisspellList() {
  const listEl = document.getElementById("misspellList");
  if (!listEl) return;
  listEl.innerHTML = "";

  const words = Object.keys(misspellAttemptsByWord);
  if (words.length === 0) {
    const empty = document.createElement("li");
    empty.className = "misspell-empty";
    empty.textContent = "No misspellings yet.";
    listEl.appendChild(empty);
    return;
  }

  // Show most recently updated words first so current practice mistakes stay visible.
  words.reverse().forEach((word) => {
    const row = document.createElement("li");
    row.className = "misspell-item";

    const title = document.createElement("div");
    title.className = "misspell-word";
    title.textContent = word.toUpperCase();

    const attempts = document.createElement("div");
    attempts.className = "misspell-attempts";
    attempts.textContent = misspellAttemptsByWord[word].join(", ");

    row.appendChild(title);
    row.appendChild(attempts);
    listEl.appendChild(row);
  });
}

function renderTenseOptions() {
  const section = document.getElementById("tenseSection");
  const optionsEl = document.getElementById("tenseOptions");
  optionsEl.innerHTML = "";
  section.classList.add("active");

  // The options are fixed, but the correct answer depends on which form was selected for the prompt.
  ["v1", "v2"].forEach((formKey) => {
    const btn = document.createElement("button");
    btn.className = "option-btn";
    btn.textContent = formKey.toUpperCase();
    btn.onclick = () => chooseTense(formKey, btn);
    optionsEl.appendChild(btn);
  });
}

function chooseTense(selectedForm, clickedBtn) {
  if (stage !== "tense") return;
  const isCorrect = selectedForm === currentPromptForm;

  if (!isCorrect) {
    playTone("error");
    streak = 0;
    updateScoreDisplay();
    clickedBtn.classList.add("wrong");
    setFeedback("‚ùå Not this one. Try again: is the spoken word V1 or V2?", "bad");
    return;
  }

  // Once V1/V2 is identified, lock this step and reveal Hebrew options.
  Array.from(document.querySelectorAll("#tenseOptions .option-btn")).forEach((btn) => {
    btn.disabled = true;
    if (btn.textContent.toLowerCase() === selectedForm) btn.classList.add("correct");
  });

  playTone("win");
  stage = "hebrew";
  updateStepIndicator();
  renderHebrewOptions();
  setFeedback("‚úÖ Great! Now pick the matching Hebrew meaning.", "good");
}

function renderHebrewOptions() {
  const section = document.getElementById("hebrewSection");
  const optionsEl = document.getElementById("hebrewOptions");
  optionsEl.innerHTML = "";
  section.classList.add("active");

  // Build 5 options total: 1 correct + 4 unique distractors from the same pool.
  const allMeanings = wordPool.map((item) => item.hebrew).filter(Boolean);
  const distractors = shuffleArray(
    allMeanings.filter((meaning) => meaning !== currentEntry.hebrew)
  );
  const selected = [currentEntry.hebrew, ...distractors.slice(0, 4)];
  const finalOptions = shuffleArray(selected);

  finalOptions.forEach((meaning) => {
    const btn = document.createElement("button");
    btn.className = "option-btn";
    btn.textContent = meaning;
    btn.onclick = () => chooseHebrew(meaning, btn);
    optionsEl.appendChild(btn);
  });
}

function chooseHebrew(selectedMeaning, clickedBtn) {
  if (stage !== "hebrew") return;
  const isCorrect = selectedMeaning === currentEntry.hebrew;

  if (!isCorrect) {
    playTone("error");
    streak = 0;
    updateScoreDisplay();
    clickedBtn.classList.add("wrong");
    setFeedback("‚ùå Not the right meaning. Try another option.", "bad");
    return;
  }

  // This is the end of the full round, so score and counters are updated here.
  playTone("win");
  score += Math.max(1, 10 - failures * 2) + 5;
  streak++;
  localStorage.setItem(SCORE_KEY, score);
  updateScoreDisplay();
  spawnConfetti();

  Array.from(document.querySelectorAll("#hebrewOptions .option-btn")).forEach((btn) => {
    btn.disabled = true;
    if (btn.textContent === currentEntry.hebrew) btn.classList.add("correct");
  });

  stage = "complete";
  updateStepIndicator();
  document.getElementById("wordInput").disabled = true;

  if (isChallengeComplete()) {
    // No Next button when final prompt is finished; challenge closes with final score message.
    document.getElementById("nextInlineBtn").style.display = "none";
    setTimeout(showChallengeCompleteThenRestart, 120);
    return;
  }

  document.getElementById("nextInlineBtn").style.display = "block";
  setFeedback("üéâ Perfect! Spelling, form, and meaning are all correct.", "good");
}

// ‚îÄ‚îÄ Hints ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderHints() {
  const area = document.getElementById("hintArea");
  area.innerHTML = "";
  if (failures < 3 || !currentPromptWord) return;

  // Reveal letters gradually after repeated misses to keep challenge while preventing frustration.
  const lettersRevealed = failures >= 5 ? failures - 4 : 0;

  currentPromptWord.split("").forEach((letter, i) => {
    const box = document.createElement("div");
    box.className = "letter-box";
    if (i < lettersRevealed) {
      box.textContent = letter.toUpperCase();
      box.classList.add("revealed");
    }
    area.appendChild(box);
  });
}

function renderFailureDots() {
  const container = document.getElementById("failureDots");
  container.innerHTML = "";
  const total = 7;
  for (let i = 0; i < total; i++) {
    const d = document.createElement("div");
    d.className = "fdot" + (i < failures ? " lit" : "");
    container.appendChild(d);
  }
}

// ‚îÄ‚îÄ UI helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setFeedback(msg, type) {
  const el = document.getElementById("feedback");
  el.textContent = msg;
  el.className = "feedback" + (type ? " " + type : "");
}

function updateScoreDisplay() {
  document.getElementById("scoreVal").textContent = score;
  document.getElementById("streakVal").textContent = "üî• " + streak;
  document.getElementById("wordsVal").textContent = `${attemptedPromptKeys.size}/${getTotalPromptCount()}`;
}

// ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function shuffleArray(arr) {
  const copy = [...arr];
  for (let i = copy.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [copy[i], copy[j]] = [copy[j], copy[i]];
  }
  return copy;
}

function normalizePoolItem(item) {
  if (!item || typeof item !== "object") return null;
  const v1 = String(item.v1 || "").trim();
  const v2 = String(item.v2 || "").trim();
  const hebrew = String(item.hebrew || "").trim();
  if (!v1 || !v2 || !hebrew) return null;
  return { v1, v2, hebrew };
}

function parsePoolRow(line) {
  const parts = line.split("|").map((part) => part.trim());
  if (parts.length !== 3) return null;
  const [v1, v2, hebrew] = parts;
  if (!v1 || !v2 || !hebrew) return null;
  return { v1, v2, hebrew };
}

function serializePool(list) {
  return list.map((item) => `${item.v1} | ${item.v2} | ${item.hebrew}`).join("\n");
}

// ‚îÄ‚îÄ Confetti ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function spawnConfetti() {
  const colors = ["#f59e0b", "#10b981", "#3b82f6", "#ec4899", "#fbbf24", "#34d399"];
  for (let i = 0; i < 60; i++) {
    const el = document.createElement("div");
    el.className = "confetti-piece";
    el.style.cssText = `
      left: ${Math.random() * 100}vw;
      top: -10px;
      background: ${colors[Math.floor(Math.random() * colors.length)]};
      --dur: ${1.2 + Math.random() * 1.5}s;
      transform: rotate(${Math.random() * 360}deg);
      border-radius: ${Math.random() > 0.5 ? "50%" : "2px"};
      width: ${6 + Math.random() * 8}px;
      height: ${6 + Math.random() * 8}px;
    `;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 3000);
  }
}

// ‚îÄ‚îÄ Stars background ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createStars() {
  const c = document.getElementById("stars");
  for (let i = 0; i < 80; i++) {
    const s = document.createElement("div");
    const size = 1 + Math.random() * 2.5;
    s.className = "star-dot";
    s.style.cssText = `
      left:${Math.random() * 100}%;
      top:${Math.random() * 100}%;
      width:${size}px; height:${size}px;
      --d:${2 + Math.random() * 4}s;
      animation-delay:${-Math.random() * 4}s;
    `;
    c.appendChild(s);
  }
}

// ‚îÄ‚îÄ Word Pool ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadPool() {
  const saved = localStorage.getItem(STORAGE_KEY);
  const legacy = localStorage.getItem(LEGACY_STORAGE_KEY);

  // Prefer the new structured storage; if missing, gracefully fallback to defaults.
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      const normalized = Array.isArray(parsed) ? parsed.map(normalizePoolItem).filter(Boolean) : [];
      wordPool = normalized.length > 0 ? normalized : [...DEFAULT_WORDS];
    } catch {
      wordPool = [...DEFAULT_WORDS];
    }
  } else if (legacy) {
    // Old string-only pools do not contain v1/v2/hebrew, so we reset to structured defaults.
    wordPool = [...DEFAULT_WORDS];
    localStorage.removeItem(LEGACY_STORAGE_KEY);
  } else {
    wordPool = [...DEFAULT_WORDS];
  }

  document.getElementById("poolTextarea").value = serializePool(wordPool);
  document.getElementById("wordCountBadge").textContent = wordPool.length + " verbs";
  buildPromptDeck();
  updateScoreDisplay();
}

function savePool() {
  const raw = document.getElementById("poolTextarea").value;
  const rows = raw.split("\n").map((line) => line.trim()).filter(Boolean);
  const parsedPool = rows.map(parsePoolRow).filter(Boolean);

  if (parsedPool.length === 0) {
    setFeedback("‚ö†Ô∏è Please add at least one valid row: V1 | V2 | Hebrew", "bad");
    return;
  }

  wordPool = parsedPool;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(wordPool));
  document.getElementById("poolTextarea").value = serializePool(wordPool);
  document.getElementById("wordCountBadge").textContent = wordPool.length + " verbs";
  // Updating the pool changes challenge size, so the non-repeating deck is rebuilt.
  buildPromptDeck();
  updateScoreDisplay();
  setFeedback("‚úÖ Word pool saved! (" + wordPool.length + " verbs)", "good");
}

function renderVersionBadge() {
  const badge = document.getElementById("versionBadge");
  if (!badge) return;
  // Prefix with 'v' for familiar semantic-version display style.
  badge.textContent = "v" + VERSION;
}

// ‚îÄ‚îÄ Boot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
renderVersionBadge();
createStars();
initVoices();
loadPool();
startOverGame(false);
</script>
</body>
</html>
